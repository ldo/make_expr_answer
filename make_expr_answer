#!/usr/bin/python3
#+
# Given n positive integers, try to use any combination of integer addition, subtraction,
# multiplication and division to try to come up with a specified result. This script can
# be invoked in two ways. Do it as follows:
#
#     make_expr_answer solve n1 n2 n3 ... target
#
# where the arguments are sequence of positive integers, the last one being the target
# value to achieve, and the others being the operands to use to produce that answer.
# The output will be the possible solutions, one to a line. Alternatively, invoke it like
# this:
#
#     make_expr_answer count n target
#
# and it will go through all possible combinations of n digits each in the range 1..9,
# and count up the number of ways each such combination can yield the target value.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

import sys

#+
# Miscellaneous useful stuff
#-

def permute(seq) :
    "generator which yields successive distinctive permutations of the elements of seq." \
    " Correctly skips duplicate permutations of duplicate elements."

    def do_permute(seq) :
        if len(seq) == 0 :
            yield ()
        else :
            prev = None
            for i in range(0, len(seq)) :
                if seq[i] != prev :
                    for rest in permute(seq[:i] + seq[i + 1:]) :
                        yield (seq[i],) + rest
                    #end for
                #end if
                prev = seq[i]
            #end for
        #end if
     #end do_permute

#begin permute
    return do_permute(sorted(seq))
#end permute

def digit_combinations(n) :
    "generator which yields all possible combinations of n of the digits 1..9." \
    " Correctly skips duplicate permutations of duplicate elements."

    def do_combine(remaining, used) :
        for i in range(max(used + (1,)), 10) :
            if remaining > 1 :
                for rest in do_combine(remaining - 1, used + (i,)) :
                    yield rest
                #end for
            else :
                yield used + (i,)
            #end if
        #end for
    #end do_combine

#begin digit_combinations
    return do_combine(n, ())
#end digit_combinations

#+
# Expression representation and evaluation
#-

class Expr :
    "represents an expression."

    def __init__(self, op, opnds) :
        self.op = op
        if len(opnds) < 2 :
            raise RuntimeError("need at least 2 operands")
        #end if
        self.opnds = tuple(opnds)
    #end __init__

    def eval(self) :
        "returns the value of the expression as a tuple of 2 values, the second" \
        " being an indication of validity."
        result = self.op.func(self.opnds[0], self.opnds[1])
        i = 2
        while result[1] and i < len(self.opnds) :
            result = self.op.func(Num(result[0]), self.opnds[i])
            i += 1
        #end while
        return result
    #end eval

    def display(self) :
        "returns a formatted represention of the expression."
        return \
            "(" + (" %s " % self.op.display()).join(x.display() for x in self.opnds) + ")"
    #end display

#end Expr

class Num :
    "represents a single number."

    def __init__(self, val) :
        self.val = val
    #end __init__

    def eval(self) :
        "returns the value of the number as a tuple of 2 values, the second" \
        " being an indication of validity (always True)."
        return self.val, True
    #end eval

    def display(self) :
        "returns a formatted represention of the number."
        return str(self.val)
    #end display

#end Num

class Op :
    "constructs an operator."

    def __init__(self, name, func, groupable) :
        "“groupable” indicates that this operator is both commutative and associative."
        self.name = name
        self.func = func
        self.groupable = groupable
    #end __init__

    def construct(self, a, b) :
        "constructs an expression using the operator and the specified operands."

        def flatten(subexpr) :
            "if subexpr has the same operator as myself and I am groupable, returns a list of" \
            " its (recursively) extracted operands, so I can group them into single operator" \
            " instance."
            if self.groupable and isinstance(subexpr, Expr) and subexpr.op.func == self.func :
                result = []
                for opnds in flatten(subexpr.opnds) :
                    result.extend(opnds)
                #end if
            else :
                result = [subexpr]
            #end if
            return result
        #end flatten

        def canonical(expr) :
            "defines a canonical ordering for operands of a groupable operator."
            if isinstance(expr, Expr) or isinstance(expr, Num) :
                key, valid = expr.eval()
                if not valid :
                    key = 0
                #end if
            else :
                raise RuntimeError("unexpected expr type %s" % repr(type(expr)))
            #end if
            return key
        #end canonical

    #begin construct
        opnds = flatten(a) + flatten(b)
        if self.groupable :
            opnds = sorted(opnds, key = canonical)
        #end if
        return Expr(self, opnds)
    #end construct

    def display(self) :
        "returns a formatted represention of the operator applied to its operands."
        return self.name
    #end display

#end Op

def add(a, b) :
    "addition operation, always valid if operands are valid."
    a = a.eval()
    b = b.eval()
    return a[0] + b[0], a[1] and b[1]
#end add

def sub(a, b) :
    "subtraction operation, valid if operands are valid and" \
    " first operand is not less than second."
    a = a.eval()
    b = b.eval()
    return a[0] - b[0], a[1] and b[1] and a[0] >= b[0]
#end sub

def mul(a, b) :
    "addition operation, always valid if operands are valid."
    a = a.eval()
    b = b.eval()
    return a[0] * b[0], a[1] and b[1]
#end mul

def intdiv(a, b) :
    "division operation, valid if operands are valid and" \
    " second operand is not zero and first operand is exactly divisible by second."
    a = a.eval()
    b = b.eval()
    return a[0] // b[0] if b[0] != 0 else 0, a[1] and b[1] and b[0] != 0 and a[0] % b[0] == 0
#end intdiv

operators = \
    ( # list of all the valid operators
        Op("+", add, True),
        Op("-", sub, False),
        Op("×", mul, True),
        Op("÷", intdiv, False),
    )

def choose_ops(nr) :
    "generator which yields all combinations of the specified number of operators."
    if nr == 0 :
        yield ()
    else :
        for rest in choose_ops(nr - 1) :
            for op in operators :
                yield (op,) + rest
            #end for
        #end for
    #end if
#end choose_ops

def solve(numbers, target, answer) :
    "numbers is a tuple of integers to try to arrange," \
    " target is the target integer value to evaluate to," \
    " and answer is the callback to invoke with each formatted" \
    " answer line."

    def signature(expr) :
        "computes a unique identifying signature for Expr so I can spot duplicates."
        if isinstance(expr, Expr) :
            result = (expr.op.name,) + tuple(signature(opnd) for opnd in expr.opnds)
        elif isinstance(expr, Num) :
            result = (expr.val,)
        else :
            raise RuntimeError("unexpected expr type %s" % repr(type(expr)))
        #end if
        return result
    #end signature

    def iter_subexpr(numbers) :
        "iterates over all possible expressions that can be constructed from" \
        " the specified tuple of numbers in the specified order."
        if len(numbers) > 0 :
            if len(numbers) > 1 :
                for splitpoint in range(1, len(numbers)) :
                    for op in operators :
                        for operand1 in iter_subexpr(numbers[:splitpoint]) :
                            for operand2 in iter_subexpr(numbers[splitpoint:]) :
                                yield op.construct(operand1, operand2)
                            #end for
                        #end for
                    #end for
                #end for
            else :
                yield Num(numbers[0])
            #end if
        #end if
    #end iter_subexpr

#begin solve
    seen = set()
    for perm in permute(numbers) :
        for expr in iter_subexpr(perm) :
            sig = signature(expr)
            if sig not in seen :
                val, ok = expr.eval()
                if ok and val == target :
                    answer("%s = %d" % (expr.display(), target))
                #end if
                seen.add(sig)
            #end if
        #end for
    #end for
#end solve

#+
# Mainline
#-

if len(sys.argv) < 2 :
    raise RuntimeError("need at least one arg, the function to perform")
#end if
fn = sys.argv[1]
if fn == "solve" :
    if len(sys.argv) < 5 :
        raise RuntimeError("need at least three more args, the numbers to work with and the target to achieve")
    #end if
    numbers = tuple(int(n) for n in sys.argv[2:])
    target = numbers[-1]
    numbers = numbers[:-1]

    class AnswerCollector :
        nr_answers = 0

        @classmethod
        def another_answer(self, answer) :
            self.nr_answers += 1
            sys.stdout.write("%d: %s\n" % (self.nr_answers, answer))
        #end another_answer

        @classmethod
        def no_more_answers(self) :
            if self.nr_answers == 0 :
                sys.stdout.write("No answers found\n")
            #end if
        #end no_more_answers

    #end AnswerCollector

    solve(numbers, target, AnswerCollector.another_answer)
    AnswerCollector.no_more_answers()
elif fn == "count" :
    if len(sys.argv) != 4 :
        raise RuntimeError("need exactly two more args, the number of single-digit numbers, and the target to achieve")
    #end if
    n, target = tuple(int(n) for n in sys.argv[2:])

    class AnswerCounter :

        def __init__(self) :
            self.nr_answers = 0
        #end __init__

        def another_answer(self, answer) :
            self.nr_answers += 1
        #end another_answer

    #end AnswerCounter

    for c in digit_combinations(n) :
        counter = AnswerCounter()
        solve(c, target, counter.another_answer)
        sys.stdout.write("%s => %d\n" % (repr(c), counter.nr_answers))
    #end for
else :
    raise RuntimeError("unrecognized function “%s%”" % fn)
#end if
